/*!
 *  \file TreeJetCreator.cpp
 *  \brief Source file for \ref TreeJetCreator function implementation
 */
/*! \fn int TreeJetCreator(const char *filename, double R, double pT_min) ""
 *  \brief Function that open a *.root file, read particles' kinematics data and cluster them in jets, which will be stored in a tree.
 * 
 *  This function should fill the input *.root file with other trees, containing the jet structure clustered from particles' kinematics./n
 *  This is not working due to an internal bug of ROOT which complains because there is no initializer for a parameter of the jet structure:
 *  it's not easy to solve this problem, because this parameter is a pointer to the structure which is not available to the user.
 *  The problem is avoided, storing jet characteristics in standard leaves using the \ref SBTreeJetKinematicsCreator function.
 * 
 *  \param *filename Name of the *.root file that will include trees filled with jet read from kinematics trees.
 *  \param R Jet radius, usually related to the angular reach of the jet. Can be found in the anti-kT algorithm formula
 *  \param pT_min Minimum transverse jet momentum that is accepted for user's analysis
 */
#include "headers/TreeJetCreator.h"

/*It can be useful to use these namespaces*/
using namespace std;
using namespace fastjet;

int TreeJetCreator(const char *filename, double R, double pT_min)
{
  /*Defining useful variables*/
  char nomefile[256];
  strcpy(nomefile, filename);
  strcat(nomefile, ".root");
  Double_t pT, eta, phi;

  /*
      Here jet clustering algorithm properties are chosen:
      -which clustering algorithm should be used;
      -radius of the cone generated by jetted particles;
      -recombination scheme, usually set to E, that simply adds particles' kinematics 4-vectors;
      -strategy, usually set to best, which choose fastest way of clustering.
    */
  JetDefinition jet_def = JetDefinition(antikt_algorithm, R, E_scheme, Best);
  vector<PseudoJet> particelle, jets;

  //Defining the output file and the tree
  TFile rootfile(nomefile, "update");
  if (rootfile.Get("Jet_tree") != 0)
    rootfile.Get("Jet_tree")->Delete("all");
  TTree Jet_tree("Jet_tree", "Jet_tree");
  TBranch *jetbranch = Jet_tree.Branch("Jet", &jets);
  TTree *alberello = (TTree *)rootfile.Get("Alberello3");
  Double_t value;
  TBranch *block0values = alberello->GetBranch("block0_values");
  block0values->SetAddress(&value);

  //read only the destep branch for all entries
  Int_t nentries = (Int_t)alberello->GetEntries();
  Int_t i = 0, j = 0;
  for (i = 0; i < nentries; i += dataset_info_list[3].get_column())
  {
    particelle.clear();
    jets.clear();
    for (j = 0; j <= dataset_info_list[3].get_column() - 3; j += 3)
    {
      block0values->GetEntry(i + dataset_info_list[3].get_column() - 1);
      block0values->GetEntry(i + j);
      if (value > 0)
      {
        pT = value;
        block0values->GetEntry(i + j + 1);
        eta = value;
        block0values->GetEntry(i + j + 2);
        phi = value;
        particelle.push_back(PseudoJet(pT * cos(phi), pT * sin(phi), pT * sinh(eta), pT * cosh(eta)));
      }
    }
    ClusterSequence cluster_seq(particelle, jet_def);
    jets = sorted_by_pt(cluster_seq.inclusive_jets(pT_min));
    jetbranch->Fill();
  }
  Jet_tree.Write("");
  return 0;
}